## url输入后都做了什么事情
1. 解析 URL：浏览器会解析输入的 URL，提取出协议（如 HTTP、HTTPS）、主机名、端口号和路径等信息。
2. DNS 解析：如果输入的 URL 中包含主机名而非 IP 地址，浏览器将执行 DNS 查询，将主机名解析为对应的 IP 地址。这样浏览器才能知道要连接的服务器地址。
3. 建立 TCP 连接：浏览器通过使用解析得到的 IP 地址和端口号，与服务器建立 TCP 连接。这是通过三次握手来完成的，确保客户端和服务器之间的通信可靠。
4. 发送 HTTP 请求：一旦建立了 TCP 连接，浏览器会构建一个 HTTP 请求，并将其发送到服务器。请求中包含了请求方法（GET、POST 等）、路径、HTTP 头部和请求体（对于 POST 请求）等信息。
5. 服务器处理请求：服务器接收到请求后，会根据请求的内容执行相应的操作，如处理页面请求、查询数据库等。
6. 服务器发送响应：服务器处理完请求后，会生成一个 HTTP 响应，并将其发送回给浏览器。响应包含了状态码、HTTP 头部和响应体等信息。
7. 接收响应：浏览器接收到服务器的响应后，会根据响应的内容执行相应的操作。如果是 HTML 页面，浏览器会解析 HTML，并请求其中引用的其他资源，如 CSS、JavaScript、图片等。
8. 渲染页面：浏览器会根据 HTML、CSS 和 JavaScript 等资源，将页面内容渲染到用户的屏幕上，呈现给用户。
9. 执行 JavaScript：如果页面中包含 JavaScript 代码，浏览器会执行该代码，以实现交互功能、动态效果等。
10. 完成加载：一旦页面的所有资源都被加载和渲染完毕，浏览器会触发相应的事件，标志着页面加载完成。

## 浏览器是怎么去解析html的
浏览器解析HTML的过程通常包括以下几个步骤：

1. 获取HTML文件： 浏览器通过HTTP请求从服务器获取HTML文件。
2. 构建DOM树： 浏览器将HTML文档解析成DOM（Document Object Model）树。DOM树是一个树状结构，表示文档的层次结构，其中每个HTML元素都是树中的一个节点。
3. 构建CSSOM树： 浏览器会同时解析CSS文件，构建CSSOM（CSS Object Model）树，用于表示CSS规则和样式信息。
4. 合并DOM树和CSSOM树： 浏览器将DOM树和CSSOM树合并成一个渲染树（Render Tree），渲染树包含了页面中需要显示的所有节点以及它们的样式信息。
5. 布局和渲染： 浏览器根据渲染树中的信息进行布局（Layout）和渲染（Painting），确定每个节点在页面中的位置和样式，并将其显示在用户界面上。

## 什么是回流和重绘  怎么避免
回流（Reflow）：当页面布局和几何属性发生改变，浏览器需要重新计算元素的几何属性（位置、大小等），然后更新渲染树和页面布局，这个过程称为回流。回流会影响到页面的整体布局，因此是比较昂贵的操作。

重绘（Repaint）：当元素的样式改变，但不影响其布局（如颜色、背景色等），浏览器会重新绘制该元素，而不需要重新计算布局，这个过程称为重绘。重绘比回流消耗的资源要少，但仍然会影响性能。

使用 CSS3 动画和变换代替 JavaScript 操作： CSS3 动画和变换通常能够利用 GPU 加速，性能更高，而不会触发回流和重绘。
合并多次 DOM 操作： 尽量避免频繁地对 DOM 进行操作，可以将多个操作合并为一次，减少回流和重绘的次数。
使用文档片段（Document Fragment）： 在需要频繁插入大量节点时，可以使用文档片段来构建节点，然后一次性插入到文档中，减少回流次数。
优化样式变化： 尽量避免修改影响布局的样式属性（如宽度、高度、位置等），如果需要修改，可以使用定位或 CSS3 transform 等方式，减少回流的影响。
使用 requestAnimationFrame： 对于需要频繁进行动画或样式变化的操作，可以使用 requestAnimationFrame 方法来优化，浏览器会在下一次重绘前执行相关操作，以提高性能。
缓存布局信息： 如果需要多次读取元素的位置或大小等信息，可以将这些信息缓存起来，避免多次触发回流。


## javascript执行的流程/javascript的运行机制
JavaScript 的运行机制是基于事件循环（Event Loop）的单线程执行模型。

## defer和async的区别
defer推迟
async异步
html在执行的过程中 如果遇到了javascript标签就会停下了加载执行javascript，如果是用的外部js，还会先进行加载并执行，整个网页的加载会造成很大的影响。
async会立即执行脚本的下载和执行，但是不会阻塞html的解析
defer是会立即下载脚本，但是需要等到html解析完成之后再去执行，因此defer会适合和dom相关联的脚本
这两个都只适合外部的脚本，并且也要注意兼容性的问题

## 事件循环机制
同步的代码放到运行栈中去执行
异步任务会放到任务队列中
事件循环不断检测任务队列中有没有任务需要执行

## 为什么setTimeout不准确
到了时间后会吧要执行的任务插入到任务队列中
至于什么时候执行要看执行栈什么时候完成

## 宏任务和微任务
宏任务（macrotask） 是由 JavaScript 运行时环境（比如浏览器或 Node.js）所提供的任务，例如：
执行整体的 JavaScript 代码（Script Execution）
定时器事件（setTimeout、setInterval）
事件监听器（DOM 事件、WebSocket 事件、IndexedDB）
Ajax 请求的回调函数

微任务（microtask） 是在宏任务执行结束后立即执行的任务，它们在事件循环的当前轮次结束时执行，例如：
Promise 的回调函数
async/await 中的异步操作的后续代码
MutationObserver 的回调函数

下面是事件循环中宏任务和微任务的执行顺序：
执行一个宏任务（例如执行整体的 JavaScript 代码）。
当宏任务执行完成后，在宏任务的结束处，执行所有微任务队列中的任务。
检查是否需要执行 UI 渲染操作，如果需要则执行（如果浏览器环境支持）。
执行下一个宏任务，重复步骤 2 和步骤 3。

## 宏任务和微任务的优先级哪个更高
在 JavaScript 中，微任务的优先级高于宏任务。这意味着在事件循环中，微任务会在下一个宏任务之前执行。

具体来说，当一个宏任务执行完成后，在宏任务的结束处，会立即执行所有微任务队列中的任务，然后再执行下一个宏任务。这种机制确保了微任务能够在当前宏任务结束后尽快执行，以提高响应性和性能。

微任务的典型例子包括 Promise 的回调函数、async/await 中的异步操作的后续代码等。因此，尽管 JavaScript 是单线程执行的，但通过微任务可以实现一些异步操作，避免了阻塞式的执行方式，使得代码能够更加高效地处理异步任务。

## 什么是同步 什么是异步
同步是按照顺序执行的
异步： setTimeout setInterval ajax 读取文件
同步程序执行完毕后 执行异步程序

## process.nextTick(callback) 和 setImmediate
process.nextTick(callback) 同步代码执行完成之后 异步代码执行执行 开始执行
异步之后执行setImmediate，也就是当前事件循环结束之后执行
